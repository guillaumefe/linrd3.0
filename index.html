<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Linrd</title>
  <link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sugar/2.0.6/sugar.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lachrono@1.3.12/chrono.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; background-color: #f4f4f9; padding-top: 50px; }
    header { background-color: #000; color: #fff; display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; }
    header .app-title { font-family: 'Orbitron', sans-serif; font-size: 24px; }
    .header-right { display: flex; align-items: center; }
    .header-right .about-us a { color: #fff; text-decoration: none; font-size: 18px; margin-right: 20px; }
    .hamburger-menu { position: relative; font-size: 12px; }
    .hamburger-menu button { background: none; border: none; font-size: 24px; color: #fff; cursor: pointer; }
    #export-import { position: absolute; right: 0; top: 100%; background-color: #fff; color: #000; min-width: 150px; border: 1px solid #ccc; border-radius: 3px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); display: none; z-index: 9999; flex-direction: column; }
    #export-import button { width: 100%; padding: 10px; background-color: #007bff; color: #fff; border: none; text-align: left; cursor: pointer; outline: none; font-size: 14px; }
    #export-import button:hover { background-color: #0056b3; }
    #export-import.show { display: flex; }
    #task-form { display: flex; flex-direction: column; gap: 10px; padding: 15px; background: #007bff; color: #fff; }
    #task-form input { padding: 10px; font-size: 18px; border-radius: 3px; border: 1px solid #ccc; }
    #task-form button { padding: 10px; font-size: 18px; background: #28a745; color: white; border: none; cursor: pointer; border-radius: 3px; }
    #tabs { display: flex; flex-wrap: wrap; justify-content: space-between; padding: 10px; background-color: #007bff; }
    #tabs button { flex: 1; margin: 5px; padding: 10px; font-size: 18px; background: #fff; color: #007bff; border: none; cursor: pointer; border-radius: 5px; transition: background-color 0.3s, color 0.3s; min-width: 120px; text-align: center; }
    #tabs button.active { background-color: #28a745; color: #fff; }
    #visualization { flex: 1; padding: 15px; overflow-y: auto; }
    .task-list { display: flex; flex-direction: column; gap: 15px; }
    .task { background: #ffffff; padding: 15px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); word-wrap: break-word; position: relative; display: flex; flex-direction: column; }
    .task.collapsed .description, .task.collapsed .comments, .task.collapsed .timer { display: none; }
    .task.collapsed .buttons { display: none; }
    .description { white-space: pre-wrap; word-wrap: break-word; cursor: pointer; }
    .task .buttons { display: flex; justify-content: flex-start; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    .task .buttons button { display: flex; align-items: center; gap: 5px; padding: 10px; font-size: 16px; color: #fff; border: none; cursor: pointer; border-radius: 3px; justify-content: flex-start; flex: 1; max-width: 150px; transition: opacity 0.3s; opacity: 0.8; }
    .task .buttons button:hover { opacity: 1; }
    .btn-done { background-color: #28a745; }
    .btn-cancel { background-color: #d9534f; }
    .btn-delay { background-color: #ffc107; color: #000; }
    .btn-await { background-color: #17a2b8; }
    .btn-doc { background-color: #6f42c1; }
    .btn-delete { background-color: #dc3545; }
    .comments { margin-top: 10px; padding-left: 20px; border-left: 3px solid #007bff; }
    .comment-item { display: flex; flex-wrap: wrap; align-items: center; padding: 1px 0; }
    .comment-item p { width: 100%; margin: 0; }
    .comment-item p { cursor: pointer; flex: 1; margin: 0; font-size: 14px; font-family: courrier-new; white-space: pre-wrap; word-wrap: break-word; }
    .comment-item .convert-button, .comment-item .delete-button { background-color: #007bff; color: white; padding: 5px; font-size: 12px; border: none; border-radius: 3px; cursor: pointer; margin-left: 5px; }
    .comment-item .delete-button { background-color: #d9534f; }
    .toggle-icon { cursor: pointer; margin-left: 10px; color: #555; }
    .drag-handle { cursor: grab; margin-right: 10px; color: #555; }
    .drag-handle:active { cursor: grabbing; }
    .timer { display: flex; align-items: center; gap: 5px; font-size: 14px; color: #555; margin-top: 5px; cursor: pointer; }
    .comment_input { width: 100%; }
    .rationale-item { background-color: #fff3cd; padding: 5px; border-left: 4px solid #ffecb5; margin: 5px 0; }
    .btn-inbox { background-color: #007bff; color: #fff; }
    .btn-someday { background-color: #FFD700; color: #000; }
    .task h3, p { word-wrap: break-word; overflow-wrap: break-word; flex-shrink: 1; min-width: 0; max-width: 100%; }
    @media screen and (max-width: 800px) {
      .comment-item { display: block; }
      .comment-item p { display: block; margin-bottom: 5px; }
      .comment-item span, .comment-item .convert-button, .comment-item .delete-button { display: inline-block; vertical-align: middle; margin-right: 5px; }
    }
    #options-popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #fff; border: 1px solid #ccc; padding: 20px; z-index: 2000; box-shadow: 0 2px 10px rgba(0,0,0,0.5); }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <div class="app-title">Linrdv3</div>
    </div>
    <div class="header-right">
      <div class="hamburger-menu">
        <button id="export-import-toggle" onclick="toggleExportImport()">☰</button>
        <div id="export-import">
          <button onclick="exportData()">Export Data</button>
          <button onclick="document.getElementById('import-file').click()">Import Data</button>
          <input type="file" id="import-file" onchange="importData(event)" style="display:none;">
          <button class="btn-reset" onclick="resetInterface()">Reset</button>
          <button onclick="openOptionsPopup()">Options</button>
        </div>
      </div>
    </div>
  </header>
  <form id="task-form">
    <input type="text" id="new-task-name" placeholder="Task Name" required>
    <textarea id="new-task-description" style="min-width:99.5%;max-width:99.5%;" placeholder="Description"></textarea>
    <button type="submit">Add</button>
  </form>
  <div id="tabs">
    <button onclick="changeTab('inbox')" class="active">Inbox (<span class="badge" id="count-inbox">0</span>)</button>
    <button onclick="changeTab('done')">Done</button>
    <button onclick="changeTab('cancel')">Cancel</button>
    <button onclick="changeTab('delay')">Delay (<span class="badge" id="count-delay">0</span>)</button>
    <button onclick="changeTab('await')">Await (<span class="badge" id="count-await">0</span>)</button>
    <button onclick="changeTab('doc')">Doc</button>
    <button onclick="changeTab('someday')">Someday</button>
  </div>
  <div id="search-container" style="background-color: #f4f4f9;display:flex;margin-top:0.2%;">
    <input type="text" id="search-input" placeholder="Search tasks..." oninput="performSearch()" style="font-size: 16px;flex: 0 0 97.5%;padding:1%;">
  </div>
  <div id="sort-menu" style="width: 100%; padding: 10px; background-color: #e9e9e9; display: flex; justify-content: center; align-items: center;">
    <label for="sort-order-menu" style="margin-right: 10px; font-size: 16px;">Sort Order:</label>
    <select id="sort-order-menu" style="font-size: 16px; padding: 5px;">
      <option value="asc">Oldest to Newest</option>
      <option value="desc">Newest to Oldest</option>
      <option value="custom">Custom Sort</option>
    </select>
  </div>
  <div id="visualization">
    <div class="task-list" id="task-list"></div>
  </div>
  <div id="options-popup">
    <h2>Options</h2>
    <label for="max-undo-input">Maximum Undo Steps:</label>
    <input type="number" id="max-undo-input" min="1" value="50" style="margin-bottom: 10px;" />
    <br>
    <button onclick="saveOptions()">Save</button>
    <button onclick="closeOptionsPopup()">Close</button>
  </div>
  <script>
    if(typeof Sugar==='undefined'){console.error("Sugar.js is not loaded correctly. Please check the script inclusion.");}
    let tasks = [];
    let taskIdCounter = 0;
    let currentTab = 'inbox';
    let worker;
    let countdownInterval;
    let undoStack = [];
    let redoStack = [];
    let maxUndo = parseInt(localStorage.getItem('maxUndo')) || 50;
    let currentSortOrder = localStorage.getItem('sortOrder') || 'desc';
    window.addEventListener('load', function(){
      const savedTab = localStorage.getItem('currentTab');
      if(savedTab){ currentTab = savedTab; } else { currentTab = 'inbox'; }
      changeTab(currentTab);
      const savedTasks = localStorage.getItem('tasks');
      if(savedTasks){
        try{
          tasks = JSON.parse(savedTasks);
          const maxId = tasks.reduce(function(max, task){ return task.id > max ? task.id : max; }, 0);
          taskIdCounter = maxId + 1;
          renderTasks();
        } catch(error){ console.error("Error loading tasks:", error); tasks = []; taskIdCounter = 0; }
      }
      const savedForm = localStorage.getItem('taskForm');
      if(savedForm){
        const formData = JSON.parse(savedForm);
        document.getElementById('new-task-name').value = formData.name || '';
        document.getElementById('new-task-description').value = formData.description || '';
      }
      initializeWorker();
      startCountdown();
      const savedSearch = localStorage.getItem('searchInput');
      if(savedSearch){
        document.getElementById('search-input').value = savedSearch;
        performSearch();
      }
    });
    document.getElementById('new-task-name').addEventListener('input', saveForm);
    document.getElementById('new-task-description').addEventListener('input', saveForm);
    document.getElementById('task-form').addEventListener('submit', function(event){
      event.preventDefault();
      const name = document.getElementById('new-task-name').value.trim();
      const description = document.getElementById('new-task-description').value.trim();
      if(name){
        pushUndoState();
        const now = new Date();
        const task = { id: taskIdCounter++, name: name, description: description, comments: [], status: "inbox", createdDate: now, modifiedDate: now, collapsed: true, targetDate: null, parentId: null, order: getMaxOrder('inbox') + 1 };
        tasks.push(task);
        saveAndRenderTasks();
        if(document.getElementById('search-input').value.trim() !== ""){
          updateAllTabsForSearch();
          performSearch();
        }
        document.getElementById('new-task-name').value = '';
        document.getElementById('new-task-description').value = '';
        localStorage.removeItem('taskForm');
      }
    });
    function saveForm(){
      const formData = { name: document.getElementById('new-task-name').value, description: document.getElementById('new-task-description').value };
      localStorage.setItem('taskForm', JSON.stringify(formData));
    }
    function getMaxOrder(status){
      const filtered = tasks.filter(function(task){ return task.status === status; });
      if(filtered.length === 0) return 0;
      return Math.max.apply(null, filtered.map(function(task){ return task.order || 0; }));
    }
    function pushUndoState(){
      undoStack.push(JSON.parse(JSON.stringify(tasks)));
      if(undoStack.length > maxUndo){ undoStack.shift(); }
      redoStack = [];
    }
    function undo(){
      if(undoStack.length > 0){
        redoStack.push(JSON.parse(JSON.stringify(tasks)));
        tasks = undoStack.pop();
        saveAndRenderTasks();
      }
    }
    function redo(){
      if(redoStack.length > 0){
        undoStack.push(JSON.parse(JSON.stringify(tasks)));
        tasks = redoStack.pop();
        saveAndRenderTasks();
      }
    }
    document.addEventListener("keydown", function(e){
      if(e.ctrlKey && !e.shiftKey && e.key.toLowerCase() === 'z'){
        e.preventDefault();
        undo();
      }
      if(e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'z'){
        e.preventDefault();
        redo();
      }
    });
    function saveAndRenderTasks(){
      localStorage.setItem('tasks', JSON.stringify(tasks));
      const searchQuery = document.getElementById('search-input').value.trim();
      if(searchQuery !== ""){
        performSearch();
      } else {
        renderTasks();
      }
      if(worker) { 
        worker.postMessage({ 
          action: 'updateTasks', 
          tasks: tasks.filter(t => t.status === 'delay' || t.status === 'await')
        }); 
      }
    }

    function renderTasks(){
      updateTabCounts();
      const taskList = document.getElementById('task-list');
      taskList.innerHTML = '';
      let filteredTasks = tasks.filter(task => task.status === currentTab);
      
      if(localStorage.getItem('customSort-' + currentTab) === 'true') {
        const savedOrder = JSON.parse(localStorage.getItem('customOrder-' + currentTab) || '[]');
        // Custom order
        filteredTasks.sort((a, b) => {
          const idxA = savedOrder.indexOf(a.id);
          const idxB = savedOrder.indexOf(b.id);
          return idxA - idxB;
        });
      } else {
        // CurrentSortOrder
        filteredTasks.sort((a, b) => currentSortOrder === 'asc'
          ? new Date(a.createdDate) - new Date(b.createdDate)
          : new Date(b.createdDate) - new Date(a.createdDate)
        );
      }
      filteredTasks.forEach(function(task){
        const taskEl = document.createElement('div');
        taskEl.className = 'task ' + (task.collapsed ? 'collapsed' : '');
        taskEl.setAttribute('data-task-id', task.id);
        const parentChain = getParentChain(task);
        const fullTitle = parentChain.length > 0 ? parentChain.join(' > ') + ' > ' + task.name : task.name;
        let timerHtml = '';
        if(task.status === 'delay' || task.status === 'await'){
          const remaining = getRemainingTime(task.targetDate);
          if(remaining > 0){
            timerHtml = `<div class="timer" onclick="modifyDeadline(${task.id})"><i class="fas fa-clock"></i> ${formatTime(remaining)}</div>`;
          } else {
            timerHtml = `<div class="timer" onclick="modifyDeadline(${task.id})"><i class="fas fa-clock"></i> 00:00:00</div>`;
          }
        }
        taskEl.innerHTML = `<div style="display: flex; align-items: center;">
          <i class="fas fa-bars drag-handle"></i>
          <h3 style="flex: 1;" onclick="editTaskName(event, ${task.id})">${renderTextWithLinks(fullTitle)}</h3>
          <span class="toggle-icon" onclick="toggleTask(${task.id})">${task.collapsed ? '▶️' : '▼'}</span>
        </div>
        ${timerHtml}
        <pre class="description" onclick="editTaskDescription(event, ${task.id})">${renderTextWithLinks(task.description || 'No description')}</pre>
        <div class="buttons">
          ${renderActionButton(task,'done')}
          ${renderActionButton(task,'cancel')}
          ${renderActionButton(task,'delay')}
          ${renderActionButton(task,'await')}
          ${renderActionButton(task,'doc')}
          ${renderActionButton(task,'inbox')}
          ${renderActionButton(task,'someday')}
          <button class="btn-delete" onclick="confirmDelete(${task.id})"><i class="fas fa-trash"></i> Delete</button>
        </div>
        <div class="comments" id="comments-${task.id}">
          <div style="display: flex; align-items: center; gap: 5px;">
            <textarea id="comment-input-${task.id}" class="comment_input" type="text" placeholder="Add a comment or the next action to do" oninput="saveCommentInput(${task.id}, this.value)" value="${renderTextWithLinks(getSavedCommentInput(task.id))}"></textarea>
            <button onclick="addCommentFromButton(${task.id})">Add</button>
          </div>
          <hr style="border: none; border-top: 1px solid #eee; margin: 5px 0;">
          ${renderComments(task.comments, task.id)}
        </div>`;
        taskList.appendChild(taskEl);
      });
      initializeSortable();
    }
    function renderActionButton(task, action){
      if(task.status === action){ return ''; }
      if(action === 'inbox'){
        if(task.status !== 'inbox'){
          return `<button class="btn-inbox" onclick="handleAction(${task.id}, 'inbox')">
          <i class="fas fa-inbox"></i> Inbox
          </button>`;
        } else { return ''; }
      }
      return `<button class="btn-${action}" onclick="handleAction(${task.id}, '${action}')">
      <i class="fas fa-${getIcon(action)}"></i> ${capitalize(action)}
      </button>`;
    }
    function getIcon(action){
      const icons = {'done':'check', 'cancel':'times', 'delay':'clock', 'await':'hourglass', 'doc':'file-alt', 'inbox':'inbox', 'someday':'lightbulb'};
      return icons[action] || 'question';
    }
    function capitalize(word){
      return word.charAt(0).toUpperCase() + word.slice(1);
    }
    function renderComments(comments, taskId){
      if(!comments || comments.length === 0){ return '<p>No comments.</p>'; }
      const sortedComments = comments.slice().sort(function(a, b){ return b.id - a.id; });
      return sortedComments.map(function(comment){
        if(comment.type === 'rationale'){
          return `<div class="comment-item rationale-item">
          <p onclick="editComment(event, ${taskId}, ${comment.id})">${renderTextWithLinks(comment.text)}</p>
          <span style="font-family:courrier-new;font-size:10px">${comment.date}</span>
          </div>`;
        } else {
          return `<div class="comment-item">
          <p onclick="editComment(event, ${taskId}, ${comment.id})">${renderTextWithLinks(comment.text)}</p>
          <span style="font-family:courrier-new;font-size:10px">${comment.date}</span>
          <button class="convert-button" onclick="convertCommentToTask(${taskId}, ${comment.id})">Convert to Task</button>
          <button class="delete-button" onclick="deleteComment(${taskId}, ${comment.id})">Delete</button>
          </div>`;
        }
      }).join('<hr style="border: none; border-top: 1px solid #eee; margin: 5px 0;">');
    }
    function toggleTask(taskId){
      const task = tasks.find(function(t){ return t.id === taskId; });
      if(task){ task.collapsed = !task.collapsed; saveAndRenderTasks(); }
    }
    function changeTab(tab){
      currentTab = tab;
      localStorage.setItem('currentTab', tab);
      document.querySelectorAll("#tabs button").forEach(function(button){ button.classList.remove("active"); });
      const activeButton = document.querySelector(`#tabs button[onclick="changeTab('${tab}')"]`);
      if(activeButton){ activeButton.classList.add("active"); }
      const searchQuery = document.getElementById('search-input').value.trim();
      if(searchQuery !== ""){
        performSearch();
      } else {
        renderTasks();
      }
    }
    function handleAction(taskId, actionType){
      const task = tasks.find(function(t){ return t.id === taskId; });
      if(!task){ console.error("Task with ID " + taskId + " not found."); return; }
      if(actionType === 'delay'){
        const success = modifyDeadline(taskId, true);
        if(!success){ return; }
        const rationale = prompt(`Please add a rationale for "delay":`);
        if(rationale && rationale.trim() !== ""){ addRationaleToTask(taskId, rationale.trim()); } else { alert("A rationale is required."); return; }
        task.status = 'delay';
        task.modifiedDate = new Date();
      }
      else if(actionType === 'await'){
        modifyDeadline(taskId, false);
        let rationale = prompt(`Add a rationale for "await" (optional). Leave blank or click Cancel to skip:`);
        if(!rationale || rationale.trim() === ""){ rationale = "Task awaited by user."; }
        if(rationale && rationale.trim() !== ""){ addRationaleToTask(taskId, rationale.trim()); }
        task.status = 'await';
        task.modifiedDate = new Date();
      }
      else if(actionType === 'done' || actionType === 'cancel' || actionType === 'doc'){
        const comment = prompt(`Please add a comment for "${actionType}" (leave empty to skip):`);
        if(comment && comment.trim() !== ""){ addCommentToTask(taskId, comment.trim()); }
        task.status = actionType;
        task.modifiedDate = new Date();
      }
      else if(actionType === 'someday'){
        const agree = confirm(`This action is going to be sidelined, do you agree?`);
        if(!agree){ return; }
        task.status = 'someday';
        task.modifiedDate = new Date();
      }
      else if(actionType === 'inbox'){
        if(task.status === 'delay' || task.status === 'await'){
          addRationaleToTask(taskId, 'Task put back into the inbox by user');
          task.targetDate = null;
        }
        task.status = 'inbox';
        task.modifiedDate = new Date();
      }
      pushUndoState();
      saveAndRenderTasks();
    }
    function addComment(event, taskId){
      if(event.key === 'Enter'){
        const commentText = event.target.value.trim();
        if(commentText){
          pushUndoState();
          addCommentToTask(taskId, commentText);
          event.target.value = '';
          removeSavedCommentInput(taskId);
          saveAndRenderTasks();
        }
      }
    }
    function addCommentToTask(taskId, commentText){
      const task = tasks.find(function(t){ return t.id === taskId; });
      if(task){
        commentText = formatText(commentText);
        task.comments.push({ id: Date.now(), text: commentText, date: Sugar.Date.format(new Date(), '%d/%m/%Y %H:%M:%S') });
        task.modifiedDate = new Date();
      }
    }
    function editTaskName(e, taskId){
      if(e.target.tagName.toLowerCase() === 'a'){ return; }
      const task = tasks.find(function(t){ return t.id === taskId; });
      if(task){
        const newName = prompt("Edit the task name:", task.name);
        if(newName !== null && newName.trim() !== ""){ pushUndoState(); task.name = newName.trim(); task.modifiedDate = new Date(); saveAndRenderTasks(); }
      }
    }
    function editTaskDescription(e, taskId){
      if(e.target.tagName.toLowerCase() === 'a'){ return; }
      const task = tasks.find(function(t){ return t.id === taskId; });
      if(task){
        const newDescription = prompt("Edit the task description:", task.description);
        if(newDescription !== null){ pushUndoState(); task.description = newDescription.trim(); task.modifiedDate = new Date(); saveAndRenderTasks(); }
      }
    }
    function editComment(e, taskId, commentId){
      if(e.target.tagName.toLowerCase() === 'a'){ return; }
      const task = tasks.find(function(t){ return t.id === taskId; });
      if(task){
        const comment = task.comments.find(function(c){ return c.id === commentId; });
        if(comment){
          const newText = prompt("Edit the comment:", comment.text);
          if(newText !== null && newText.trim() !== ""){ pushUndoState(); comment.text = newText.trim(); comment.date = Sugar.Date.format(new Date(), '%d/%m/%Y %H:%M:%S'); task.modifiedDate = new Date(); saveAndRenderTasks(); }
        }
      }
    }
    function confirmDelete(taskId){
      if(confirm("Are you sure you want to delete this task? All its sub-tasks will also be deleted.")){
        pushUndoState();
        deleteTask(taskId);
      }
    }
    function deleteTask(taskId){
      const deleteRecursively = function(id){
        const subTasks = tasks.filter(function(t){ return t.parentId === id; });
        subTasks.forEach(function(subTask){ deleteRecursively(subTask.id); });
        tasks = tasks.filter(function(t){ return t.id !== id; });
      };
      deleteRecursively(taskId);
      saveAndRenderTasks();
    }
    function convertCommentToTask(taskId, commentId){
      const parentTask = tasks.find(function(t){ return t.id === taskId; });
      if(!parentTask) return;
      const comment = parentTask.comments.find(function(c){ return c.id === commentId; });
      if(!comment) return;
      pushUndoState();
      const newTask = { id: taskIdCounter++, name: comment.text, description: "", comments: [], status: "inbox", createdDate: new Date(), modifiedDate: new Date(), collapsed: true, targetDate: null, parentId: parentTask.id, order: getMaxOrder('inbox') + 1 };
      tasks.push(newTask);
      parentTask.comments = parentTask.comments.filter(function(c){ return c.id !== commentId; });
      parentTask.modifiedDate = new Date();
      saveAndRenderTasks();
    }
    function getParentChain(task){
      let chain = [];
      let currentTask = task;
      while(currentTask.parentId !== null){
        const parentTask = tasks.find(function(t){ return t.id === currentTask.parentId; });
        if(parentTask){ chain.unshift(parentTask.name); currentTask = parentTask; } else { break; }
      }
      return chain;
    }
    function deleteComment(taskId, commentId){
      if(!confirm("Are you sure you want to delete this comment?")){ return; }
      const task = tasks.find(function(t){ return t.id === taskId; });
      if(task){
        const comment = task.comments.find(c => c.id === commentId);
        if(comment && comment.type === 'rationale'){ alert("You cannot delete a rationale."); return; }
        pushUndoState();
        task.comments = task.comments.filter(function(c){ return c.id !== commentId; });
        task.modifiedDate = new Date();
        saveAndRenderTasks();
      }
    }
    function saveCommentInput(taskId, value){
      localStorage.setItem('commentInput-' + taskId, value);
    }
    function getSavedCommentInput(taskId){
      return localStorage.getItem('commentInput-' + taskId) || '';
    }
    function removeSavedCommentInput(taskId){
      localStorage.removeItem('commentInput-' + taskId);
    }
    function resetInterface(){
      if(confirm("Are you sure you want to reset the interface? All tasks will be deleted.")){
        pushUndoState();
        tasks = [];
        taskIdCounter = 0;
        localStorage.removeItem('tasks');
        localStorage.removeItem('taskForm');
        localStorage.removeItem('sortOrder'); // Réinitialise également le sortOrder global
    
        // Parcours de toutes les clés de localStorage et suppression de celles liées aux custom sort et aux inputs de commentaires
        Object.keys(localStorage).forEach(function(key){
          if(key.startsWith('customSort-') || key.startsWith('customOrder-') || key.startsWith('commentInput-')){
            localStorage.removeItem(key);
          }
        });

        saveAndRenderTasks();
        updateSortMenuDisplay();
        const sortMenu = document.getElementById('sort-order-menu');
        sortMenu.value = 'desc';
      }
    }
    function exportData(){
      const data = JSON.stringify(tasks, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tasks.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    function importData(event){
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = function(e){
        try{
          const importedTasks = JSON.parse(e.target.result);
          if(Array.isArray(importedTasks)){
            pushUndoState();
            tasks = importedTasks.map(function(task){
              return Object.assign({}, task);
            });
            const maxId = tasks.reduce(function(max, task){ return task.id > max ? task.id : max; }, 0);
            taskIdCounter = maxId + 1;
            saveAndRenderTasks();
            alert("Data imported successfully!");
          } else {
            alert("The imported file is not valid.");
          }
        } catch(error){
          alert("Error importing data.");
        }
      };
      reader.readAsText(file);
    }
    function initializeWorker() {
      const workerCode = `
        function createDate(input) { return new Date(input); }
        function isBeforeOrSame(date1, date2) { return date1.getTime() <= date2.getTime(); }
    
        self.onmessage = function(event) {
          if (event.data.action === 'updateTasks') {
            const tasks = event.data.tasks;
            monitorTasks(tasks);
          }
        };
    
        function monitorTasks(tasks) {
          setInterval(function() {
            const now = new Date();
            const taskIdsToInbox = [];
            tasks.forEach(function(task) {
              if ((task.status === 'delay' || task.status === 'await') && task.targetDate) {
                const targetDate = createDate(task.targetDate);
                if (isBeforeOrSame(targetDate, now)) {
                  taskIdsToInbox.push(task.id);
                }
              }
            });
            if (taskIdsToInbox.length > 0) {
              postMessage({ action: 'moveTasksToInbox', taskIds: taskIdsToInbox });
            }
          }, 1000);
        }
      `;
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const workerURL = URL.createObjectURL(blob);
      worker = new Worker(workerURL);
      worker.onmessage = function(event) {
        if (event.data.action === 'moveTasksToInbox') {
          handleTasksReturnToInbox(event.data.taskIds);
        }
      };
      worker.postMessage({ action: 'updateTasks', tasks: tasks });
    }

    function handleTasksReturnToInbox(taskIds) {
      let hasChanges = false;
      taskIds.forEach(taskId => {
        const task = tasks.find(t => t.id === taskId);
        if (task && (task.status === 'delay' || task.status === 'await')) {
          task.status = 'inbox';
          task.modifiedDate = new Date();
          task.targetDate = null;
          task.order = getMaxOrder('inbox') + 1;
          addRationaleToTask(task.id, 'Task automatically moved to inbox after deadline.');
          hasChanges = true;
        }
      });
    
      if (hasChanges) {
        saveAndRenderTasks();
      }
    }

    function initializeSortable(){
      const taskList = document.getElementById('task-list');
      Sortable.create(taskList, { 
        animation: 150, 
        handle: '.drag-handle', 
        onEnd: function(evt){
          const taskList = document.getElementById('task-list');
          const newOrderIds = Array.from(taskList.children)
                                   .map(el => parseInt(el.getAttribute('data-task-id')));
          let count = 1;
          newOrderIds.forEach(id => {
            const task = tasks.find(t => t.id === id);
            if(task) {
              task.order = count++;
            }
          });
          
          localStorage.setItem('customOrder-' + currentTab, JSON.stringify(newOrderIds));
          localStorage.setItem('customSort-' + currentTab, 'true');
          
          document.getElementById('sort-order-menu').value = 'custom';
          
          pushUndoState();
          saveAndRenderTasks();
        }
      });
    }
    function toggleExportImport(){
      const exportImportDiv = document.getElementById('export-import');
      exportImportDiv.classList.toggle('show');
    }
    function startCountdown(){
      if(countdownInterval) clearInterval(countdownInterval);
      countdownInterval = setInterval(updateCountdowns, 1000);
    }
    function updateCountdowns(){
      tasks.forEach(function(task){
        if(task.status === 'delay'){
          const remaining = getRemainingTime(task.targetDate);
          const taskEl = document.querySelector('[data-task-id="'+task.id+'"]');
          if(taskEl){
            const timerEl = taskEl.querySelector('.timer');
            if(timerEl){ if(remaining > 0){ timerEl.innerHTML = '<i class="fas fa-clock"></i> ' + formatTime(remaining); } else { timerEl.innerHTML = '<i class="fas fa-clock"></i> 00:00:00'; } }
          }
        }
        else if(task.status === 'await'){
          if(!task.targetDate){
            const taskEl = document.querySelector('[data-task-id="'+task.id+'"]');
            if(taskEl){
              const timerEl = taskEl.querySelector('.timer');
              if(timerEl){ timerEl.innerHTML = ""; }
            }
          } else {
            const remaining = getRemainingTime(task.targetDate);
            const taskEl = document.querySelector('[data-task-id="'+task.id+'"]');
            if(taskEl){
              const timerEl = taskEl.querySelector('.timer');
              if(timerEl){ if(remaining > 0){ timerEl.innerHTML = '<i class="fas fa-clock"></i> ' + formatTime(remaining); } else { timerEl.innerHTML = '<i class="fas fa-clock"></i> 00:00:00'; } }
            }
          }
        }
      });
    }
    function getRemainingTime(targetDate){
      const now = new Date();
      const target = Sugar.Date.create(targetDate);
      return target - now > 0 ? target - now : 0;
    }
    function formatTime(ms){
      const totalSeconds = Math.floor(ms / 1000);
      const days = Math.floor(totalSeconds / 86400);
      const hours = Math.floor((totalSeconds % 86400) / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      let parts = [];
      if(days > 0){ parts.push(days + 'd'); if(hours > 0) parts.push(hours + 'h'); }
      else if(hours > 0){ parts.push(hours + 'h'); if(minutes > 0) parts.push(minutes + 'm'); }
      else if(minutes > 0){ parts.push(minutes + 'm'); if(seconds > 0) parts.push(seconds + 's'); }
      else { parts.push(seconds + 's'); }
      return parts.join(' ');
    }
    
    function parseDateExpression(input, baseDate) {
      const referenceDate = baseDate || new Date();
    
      try {
        const results = chrono.parse(input, referenceDate); // ✅ chrono est global ici
        if (results.length > 0) {
          const parsedDate = results[0].start.date();
          if (parsedDate > referenceDate) {
            return parsedDate;
          }
        }
      } catch (e) {
        console.error("Error parsing date:", e);
      }
    
      return null;
    }
    
    function modifyDeadline(taskId, isMandatory){
      const task = tasks.find(t => t.id === taskId);
      if(!task) return false;
      //const baseDate = task.modifiedDate ? new Date(task.modifiedDate) : new Date(task.createdDate);
      const baseDate = new Date();
      let newTargetDate = null;
      if(isMandatory){
        while(true){
          const dateInput = prompt(`Set a new deadline for "${task.name}" (e.g. tomorrow, next Monday, in 3 hours):`);
          if(dateInput === null){ return false; }
          const parsedDate = parseDateExpression(dateInput, baseDate);
          if(parsedDate){ newTargetDate = parsedDate; task.targetDate = newTargetDate; task.modifiedDate = new Date(); break; }
          else { alert("Please provide a valid future date."); }
        }
      } else {
        const dateInput = prompt(`Set a new deadline for "${task.name}" (optional). Leave blank or click Cancel to skip:`);
        if(dateInput === null || dateInput.trim() === ""){ task.targetDate = null; }
        else { const parsedDate = parseDateExpression(dateInput, baseDate); if(parsedDate){ newTargetDate = parsedDate; task.targetDate = newTargetDate; task.modifiedDate = new Date(); } else { alert("Invalid date. No deadline will be set."); task.targetDate = null; } }
      }
      saveAndRenderTasks();
      return true;
    }
    function addCommentFromButton(taskId){
      const inputEl = document.getElementById('comment-input-' + taskId);
      if(!inputEl) return;
      const commentText = inputEl.value.trim();
      if(commentText){
        pushUndoState();
        addCommentToTask(taskId, commentText);
        inputEl.value = '';
        removeSavedCommentInput(taskId);
        saveAndRenderTasks();
      }
    }
    function addRationaleToTask(taskId, rationaleText){
      const task = tasks.find(t => t.id === taskId);
      if(task){
        rationaleText = formatText(rationaleText);
        task.comments.push({ id: Date.now(), text: rationaleText, date: Sugar.Date.format(new Date(), '%d/%m/%Y %H:%M:%S'), type: 'rationale' });
        task.modifiedDate = new Date();
      }
    }
    function formatText(text){
      text = text.trim();
      if(text.length > 0){ text = text.charAt(0).toUpperCase() + text.slice(1); if(!text.endsWith('.')){ text += '.'; } }
      return text;
    }
    function updateTabCounts(){
      ['inbox', 'delay', 'await'].forEach(function(status){
        const count = tasks.filter(task => task.status === status).length;
        const countEl = document.getElementById('count-' + status);
        if(countEl) countEl.textContent = count;
      });
    }
    function renderTextWithLinks(text){
      if(!text) return "";
      const escaped = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
      const urlRegex = /((https?:\/\/|www\.)[^\s]+)/gi;
      const linked = escaped.replace(urlRegex, function(url){
        let href = url;
        return `<a href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
      });
      return linked;
    }
    document.addEventListener('click', function(e){
      const hamburgerMenu = document.querySelector('.hamburger-menu');
      const exportImport = document.getElementById('export-import');
      if(!hamburgerMenu.contains(e.target)){ exportImport.classList.remove('show'); }
    });

    function performSearch() {
      const query = document.getElementById('search-input').value.trim().toLowerCase();
      localStorage.setItem('searchInput', query); // Save the search input
      if (!query) {
        updateTabCounts();
        renderTasks();
        return;
      }
      
      // Update tab counts for search
      updateAllTabsForSearch();
      const terms = query.split(/\s+/);
      
      // First, filter tasks based on the search query for the current tab
      let results = tasks.filter(task => {
        if (task.status !== currentTab) return false;
        const parentChainText = getParentChain(task).join(' ');
        const combinedText = (
          parentChainText + ' ' +
          task.name + ' ' +
          (task.description || '') + ' ' +
          task.comments.map(c => c.text).join(' ')
        ).toLowerCase();
        return terms.some(term => combinedText.includes(term));
      });
      
      // Now sort the filtered results according to the sort order
      if (localStorage.getItem('customSort-' + currentTab) === 'true') {
        // When using a custom sort order, sort by the order stored in localStorage
        const savedOrder = JSON.parse(localStorage.getItem('customOrder-' + currentTab) || '[]');
        results.sort((a, b) => {
          const idxA = savedOrder.indexOf(a.id);
          const idxB = savedOrder.indexOf(b.id);
          return idxA - idxB;
        });
      } else {
        // Otherwise, sort by createdDate in ascending or descending order
        results.sort((a, b) => currentSortOrder === 'asc'
          ? new Date(a.createdDate) - new Date(b.createdDate)
          : new Date(b.createdDate) - new Date(a.createdDate)
        );
      }
      
      // Render the filtered and sorted results
      renderSearchResults(results);
    }
    
    function renderSearchResults(results){
      const taskList = document.getElementById('task-list');
      taskList.innerHTML = '';
      results.forEach(function(task){
        const taskEl = document.createElement('div');
        taskEl.className = 'task ' + (task.collapsed ? 'collapsed' : '');
        taskEl.setAttribute('data-task-id', task.id);
        const parentChain = getParentChain(task);
        const fullTitle = parentChain.length > 0 ? parentChain.join(' > ') + ' > ' + task.name : task.name;
        let timerHtml = '';
        if(task.status === 'delay' || task.status === 'await'){
          const remaining = getRemainingTime(task.targetDate);
          timerHtml = `<div class="timer" onclick="modifyDeadline(${task.id})"><i class="fas fa-clock"></i> ${remaining > 0 ? formatTime(remaining) : '00:00:00'}</div>`;
        }
        taskEl.innerHTML = `<div style="display: flex; align-items: center;">
          <i class="fas fa-bars drag-handle"></i>
          <h3 style="flex: 1;" onclick="editTaskName(event, ${task.id})">${renderTextWithLinks(fullTitle)}</h3>
          <span class="toggle-icon" onclick="toggleTask(${task.id})">${task.collapsed ? '▶️' : '▼'}</span>
        </div>
        ${timerHtml}
        <pre class="description" onclick="editTaskDescription(event, ${task.id})">${renderTextWithLinks(task.description || 'No description')}</pre>
        <div class="buttons">
          ${renderActionButton(task, 'done')}
          ${renderActionButton(task, 'cancel')}
          ${renderActionButton(task, 'delay')}
          ${renderActionButton(task, 'await')}
          ${renderActionButton(task, 'doc')}
          ${renderActionButton(task, 'inbox')}
          ${renderActionButton(task, 'someday')}
          <button class="btn-delete" onclick="confirmDelete(${task.id})"><i class="fas fa-trash"></i> Delete</button>
        </div>
        <div class="comments" id="comments-${task.id}">
          <div style="display: flex; align-items: center; gap: 5px;">
            <textarea id="comment-input-${task.id}" class="comment_input" type="text" placeholder="Add a comment that could become a subtask if you wish later on" oninput="saveCommentInput(${task.id}, this.value)" value="${renderTextWithLinks(getSavedCommentInput(task.id))}"></textarea>
            <button onclick="addCommentFromButton(${task.id})">Add</button>
          </div>
          <hr style="border: none; border-top: 1px solid #eee; margin: 5px 0;">
          ${renderComments(task.comments, task.id)}
        </div>`;
        taskList.appendChild(taskEl);
      });
    }
    function updateAllTabsForSearch(){
      const query = document.getElementById('search-input').value.trim().toLowerCase();
      const terms = query.split(/\s+/);
      const statuses = ['inbox','done','cancel','delay','await','doc','someday'];
      statuses.forEach(status => {
        const count = tasks.filter(task => {
          if(task.status !== status) return false;
          const parentChainText = getParentChain(task).join(' ');
          const combinedText = (parentChainText + ' ' + task.name + ' ' + (task.description || '') + ' ' + task.comments.map(c => c.text).join(' ')).toLowerCase();
          return terms.some(term => combinedText.includes(term));
        }).length;
        const countEl = document.getElementById('count-' + status);
        if(countEl){ countEl.textContent = count; }
      });
    }
    function openOptionsPopup(){
      document.getElementById('max-undo-input').value = maxUndo;
      document.getElementById('options-popup').style.display = 'block';
    }
    function closeOptionsPopup(){
      document.getElementById('options-popup').style.display = 'none';
    }
    function saveOptions(){
      const newMax = parseInt(document.getElementById('max-undo-input').value, 10);
      if(!isNaN(newMax) && newMax > 0){
        maxUndo = newMax;
        localStorage.setItem('maxUndo', maxUndo);
      } else { alert("Please enter a valid number."); }
      closeOptionsPopup();
    }
    function escapeRegex(string) {
       return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
     }
    document.addEventListener('DOMContentLoaded', function(){
      updateSortMenuDisplay()
      const sortMenu = document.getElementById('sort-order-menu');
      
      if(localStorage.getItem('customSort-' + currentTab) === 'true') {
        sortMenu.value = 'custom';
      } else {
        sortMenu.value = localStorage.getItem('sortOrder') || currentSortOrder;
      }
      sortMenu.addEventListener('change', function(e) {
        currentSortOrder = e.target.value;
        if (currentSortOrder !== 'custom') {
          localStorage.setItem('customSort-' + currentTab, 'false');
        } else {
          localStorage.setItem('customSort-' + currentTab, 'true');
        }
        localStorage.setItem('sortOrder', currentSortOrder);
        const searchQuery = document.getElementById('search-input').value.trim();
        if (searchQuery !== "") {
          performSearch(); // Applique le filtre ET le tri
        } else {
          renderTasks();   // Affiche l'ensemble des tâches triées
        }
      });
    });
    function updateSortMenuDisplay(){
      const sortMenu = document.getElementById('sort-order-menu');
      const customOption = sortMenu.querySelector('option[value="custom"]');
      
      // Si aucun ordre custom n'a jamais été défini (la clé n'existe pas dans localStorage)
      // on masque l'option "Custom Sort" en utilisant l'attribut hidden.
      if(localStorage.getItem('customSort-' + currentTab) === null){
        if (customOption) {
          customOption.hidden = true;
        }
      } else {
        if (customOption) {
          customOption.hidden = false;
        }
      }
    }
  </script>
</body>
</html>
