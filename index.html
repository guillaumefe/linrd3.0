<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linrd</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sugar/2.0.6/sugar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sugar/2.0.6/locales/fr.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: #f4f4f9;
        }

        #task-form {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background: #007bff;
            color: #fff;
        }

        #task-form input {
            padding: 10px;
            font-size: 18px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        #task-form button {
            padding: 10px;
            font-size: 18px;
            background: #28a745;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 3px;
        }

#tabs {
    display: flex;
    flex-wrap: wrap; /* Permet aux boutons de passer à la ligne si nécessaire */
    justify-content: space-between; /* Espace entre les boutons */
    padding: 10px;
    background-color: #007bff;
}

#tabs button {
    flex: 1;
    margin: 5px;
    padding: 10px;
    font-size: 18px;
    background: #fff;
    color: #007bff;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s, color 0.3s;
    min-width: 120px; /* Largeur minimale pour les petits écrans */
    text-align: center; /* Centrer le texte des boutons */
}


        #tabs button.active {
            background-color: #28a745;
            color: #fff;
        }

        #visualization {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
        }

        .task-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .task {
            background: #ffffff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .task.collapsed .description,
        .task.collapsed .comments,
        .task.collapsed .timer {
            display: none;
        }

        .description {
            white-space: pre-wrap;
            word-wrap: break-word;
            cursor: pointer;
        }

        .task .buttons {
            display: flex;
            justify-content: flex-start;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .task .buttons button {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 10px;
            font-size: 16px;
            color: #fff;
            border: none;
            cursor: pointer;
            border-radius: 3px;
            justify-content: flex-start;
            flex: 1;
            max-width: 150px;
            transition: opacity 0.3s;
            opacity: 0.8;
        }

        .task .buttons button:hover {
            opacity: 1;
        }

        .btn-done { background-color: #28a745; }
        .btn-cancel { background-color: #d9534f; }
        .btn-delay { background-color: #ffc107; color: #000; }
        .btn-await { background-color: #17a2b8; }
        .btn-doc { background-color: #6f42c1; }
        .btn-delete { background-color: #dc3545; }

        .comments {
            margin-top: 10px;
            padding-left: 20px;
            border-left: 3px solid #007bff;
        }

        .comment-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1px 0;
        }

        .comment-item p {
            cursor: pointer;
            flex: 1;
            margin: 0;
            font-size: 14px;
        }

        .comment-item .convert-button,
        .comment-item .delete-button {
            background-color: #007bff;
            color: white;
            padding: 5px;
            font-size: 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 5px;
        }

        .comment-item .delete-button {
            background-color: #d9534f;
        }

        .toggle-icon {
            cursor: pointer;
            margin-left: 10px;
            color: #555;
        }

        .drag-handle {
            cursor: grab;
            margin-right: 10px;
            color: #555;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .timer {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: #555;
            margin-top: 5px;
            cursor: pointer;
        }

        #export-import {
            position: relative;
            padding: 15px;
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            transition: max-height 0.3s ease, padding 0.3s ease;
            overflow: hidden;
            max-height: 300px;
        }

        #export-import.collapsed {
            max-height: 50px;
            padding: 10px;
        }

        #export-import button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #export-import button:hover {
            opacity: 0.9;
        }

        #export-import .btn-reset {
            background-color: #dc3545;
            color: white;
        }

        #export-import-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 14px;
        }

        #export-import-toggle:hover {
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <form id="task-form">
        <input type="text" id="new-task-name" placeholder="Nom de la tâche" required>
        <input type="text" id="new-task-description" placeholder="Description">
        <button type="submit">Ajouter</button>
    </form>

    <div id="tabs">
        <button onclick="changeTab('inbox')" class="active">Inbox</button>
        <button onclick="changeTab('done')">Done</button>
        <button onclick="changeTab('cancel')">Cancel</button>
        <button onclick="changeTab('delay')">Delay</button>
        <button onclick="changeTab('await')">Await</button>
        <button onclick="changeTab('doc')">Doc</button>
    </div>

    <div id="visualization">
        <div class="task-list" id="task-list"></div>
    </div>

    <div id="export-import">
        <button id="export-import-toggle" onclick="toggleExportImport()">☰</button>
        <button onclick="exportData()">Exporter les données</button>
        <button onclick="document.getElementById('import-file').click()">Importer des données</button>
        <input type="file" id="import-file" onchange="importData(event)" style="display:none;">
        <button onclick="forkApplication()">Forker l'application</button>
        <button class="btn-reset" onclick="resetInterface()">Réinitialiser</button>
    </div>

    <script>
        if (typeof Sugar === 'undefined') {
            console.error("Sugar.js n'est pas chargé correctement. Veuillez vérifier l'inclusion du script.");
        } else {
            //console.log("Sugar.js chargé avec succès :", Sugar);
        }

        let tasks = [];
        let taskIdCounter = 0;
        let currentTab = 'inbox';
        let worker;
        let countdownInterval;

        window.addEventListener('load', function() {
            const savedTasks = localStorage.getItem('tasks');
            if (savedTasks) {
                try {
                    tasks = JSON.parse(savedTasks);
                    const maxId = tasks.reduce(function(max, task) {
                        return task.id > max ? task.id : max;
                    }, 0);
                    taskIdCounter = maxId + 1;
                    renderTasks();
                } catch (error) {
                    console.error("Erreur lors du chargement des tâches :", error);
                    tasks = [];
                    taskIdCounter = 0;
                }
            }
            const savedForm = localStorage.getItem('taskForm');
            if (savedForm) {
                const formData = JSON.parse(savedForm);
                document.getElementById('new-task-name').value = formData.name || '';
                document.getElementById('new-task-description').value = formData.description || '';
            }
            const exportImportCollapsed = localStorage.getItem('exportImportCollapsed');
            if (exportImportCollapsed === 'true' || exportImportCollapsed === null) {
                document.getElementById('export-import').classList.add('collapsed');
            } else {
                document.getElementById('export-import').classList.remove('collapsed');
            }
            initializeWorker();
            startCountdown();
        });

        document.getElementById('new-task-name').addEventListener('input', saveForm);
        document.getElementById('new-task-description').addEventListener('input', saveForm);

        function saveForm() {
            const formData = {
                name: document.getElementById('new-task-name').value,
                description: document.getElementById('new-task-description').value
            };
            localStorage.setItem('taskForm', JSON.stringify(formData));
        }

        document.getElementById('task-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const name = document.getElementById('new-task-name').value.trim();
            const description = document.getElementById('new-task-description').value.trim();
            if (name) {
                const now = new Date();
                const task = {
                    id: taskIdCounter++,
                    name: name,
                    description: description,
                    comments: [],
                    status: "inbox",
                    createdDate: now,
                    modifiedDate: now,
                    collapsed: true,
                    targetDate: null,
                    parentId: null,
                    order: getMaxOrder('inbox') + 1
                };
                tasks.push(task);
                saveAndRenderTasks();
                document.getElementById('new-task-name').value = '';
                document.getElementById('new-task-description').value = '';
                localStorage.removeItem('taskForm');
            }
        });

        function getMaxOrder(status) {
            const filtered = tasks.filter(function(task) {
                return task.status === status;
            });
            if (filtered.length === 0) return 0;
            return Math.max.apply(null, filtered.map(function(task) {
                return task.order || 0;
            }));
        }

        function saveAndRenderTasks() {
            localStorage.setItem('tasks', JSON.stringify(tasks));
            renderTasks();
            if (worker) {
                worker.postMessage({ action: 'updateTasks', tasks: tasks });
            }
        }

        function renderTasks() {
    const taskList = document.getElementById('task-list');
    taskList.innerHTML = '';

    let filteredTasks = tasks.filter(function(task) {
        return task.status === currentTab;
    });

    // Pour l'onglet "Inbox", trier par date de création décroissante (les plus récentes en haut)
    if (currentTab === 'inbox') {
        filteredTasks.sort(function(a, b) {
            return new Date(b.createdDate) - new Date(a.createdDate);  // Trier par date de création descendante
        });
    } else {
        // Pour les autres catégories, trier par date de modification décroissante
        filteredTasks.sort(function(a, b) {
            return new Date(b.modifiedDate) - new Date(a.modifiedDate);  // Tri par date de modification descendante
        });
    }

    filteredTasks.forEach(function(task) {
        const taskEl = document.createElement('div');
        taskEl.className = 'task ' + (task.collapsed ? 'collapsed' : '');
        taskEl.setAttribute('data-task-id', task.id);

        const parentChain = getParentChain(task);
        const fullTitle = parentChain.length > 0 ? parentChain.join(' > ') + ' > ' + task.name : task.name;

        let timerHtml = '';
        if (task.status === 'delay' || task.status === 'await') {
            const remaining = getRemainingTime(task.targetDate);
            if (remaining > 0) {
                timerHtml = '<div class="timer" onclick="modifyDeadline(' + task.id + ')"><i class="fas fa-clock"></i> ' + formatTime(remaining) + '</div>';
            } else {
                timerHtml = '<div class="timer" onclick="modifyDeadline(' + task.id + ')"><i class="fas fa-clock"></i> 00:00:00</div>';
            }
        }

        taskEl.innerHTML = 
            '<div style="display: flex; align-items: center;">' +
                '<i class="fas fa-bars drag-handle"></i>' +
                '<h3 style="flex: 1;" onclick="editTaskName(' + task.id + ')">' + escapeHTML(fullTitle) + '</h3>' +
                '<span class="toggle-icon" onclick="toggleTask(' + task.id + ')">' + (task.collapsed ? '▶️' : '▼') + '</span>' +
            '</div>' +
            timerHtml +
            '<pre class="description" onclick="editTaskDescription(' + task.id + ')">' + escapeHTML(task.description || 'Aucune description') + '</pre>' +
            '<div class="buttons">' +
                renderActionButton(task, 'done') +
                renderActionButton(task, 'cancel') +
                renderActionButton(task, 'delay') +
                renderActionButton(task, 'await') +
                renderActionButton(task, 'doc') +
                '<button class="btn-delete" onclick="confirmDelete(' + task.id + ')"><i class="fas fa-trash"></i> Delete</button>' +
            '</div>' +
            '<div class="comments" id="comments-' + task.id + '">' +
                '<input type="text" placeholder="Ajouter un commentaire" oninput="saveCommentInput(' + task.id + ', this.value)" value="' + escapeHTML(getSavedCommentInput(task.id)) + '" onkeypress="addComment(event, ' + task.id + ')">' +
                renderComments(task.comments, task.id) +
            '</div>';
        taskList.appendChild(taskEl);
    });

    if (currentTab === 'inbox') {
        initializeSortable();
    }
}


        function escapeHTML(text) {
            if (!text) return '';
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        function renderActionButton(task, action) {
            if (task.status === action) {
                return '';
            }
            if (action === 'inbox') {
                return '';
            }
            return '<button class="btn-' + action + '" onclick="handleAction(' + task.id + ', \'' + action + '\')"><i class="fas fa-' + getIcon(action) + '"></i> ' + capitalize(action) + '</button>';
        }

        function getIcon(action) {
            const icons = {
                'done': 'check',
                'cancel': 'times',
                'delay': 'clock',
                'await': 'hourglass',
                'doc': 'file-alt'
            };
            return icons[action] || 'question';
        }

        function capitalize(word) {
            return word.charAt(0).toUpperCase() + word.slice(1);
        }

        function renderComments(comments, taskId) {
            if (!comments || comments.length === 0) {
                return '<p>Aucun commentaire.</p>';
            }
            const sortedComments = comments.slice().sort(function(a, b) {
                return b.id - a.id;
            });
            return sortedComments.map(function(comment) {
                return '<div class="comment-item">' +
                           '<p onclick="editComment(' + taskId + ', ' + comment.id + ')">' + escapeHTML(comment.text) + '</p>' +
                           '<span>' + comment.date + '</span>' +
                           '<button class="convert-button" onclick="convertCommentToTask(' + taskId + ', ' + comment.id + ')">Convertir en tâche</button>' +
                           '<button class="delete-button" onclick="deleteComment(' + taskId + ', ' + comment.id + ')">Supprimer</button>' +
                       '</div>';
            }).join('');
        }

        function toggleTask(taskId) {
            const task = tasks.find(function(t) {
                return t.id === taskId;
            });
            if (task) {
                task.collapsed = !task.collapsed;
                saveAndRenderTasks();
            }
        }

        function changeTab(tab) {
            currentTab = tab;
            document.querySelectorAll("#tabs button").forEach(function(button) {
                button.classList.remove("active");
            });
            const activeButton = document.querySelector('#tabs button[onclick="changeTab(\'' + tab + '\')"]');
            if (activeButton) {
                activeButton.classList.add("active");
            }
            renderTasks();
        }

function handleAction(taskId, actionType) {
    const task = tasks.find(function(t) {
        return t.id === taskId;
    });
    if (!task) {
        console.error("Tâche avec ID " + taskId + " non trouvée.");
        return;
    }

    // Pour 'delay' et 'await', utiliser modifyDeadline pour gérer la date
    if (actionType === 'delay' || actionType === 'await') {
        modifyDeadline(taskId);  // Appel de la fonction existante pour la gestion de la deadline

        // Ajout du commentaire après modification de la deadline
        const comment = prompt("Veuillez ajouter un commentaire pour \"" + actionType + "\" :");
        if (comment && comment.trim() !== "") {
            addCommentToTask(taskId, comment.trim());
        } else {
            alert("Le commentaire est obligatoire.");
            return;  // Sortir si aucun commentaire n'est fourni
        }

        task.status = actionType;
        task.order = undefined;  // Réinitialiser l'ordre si la tâche change de statut
    } 

    // Pour les autres actions (done, cancel, doc)
    else if (actionType === 'done' || actionType === 'cancel' || actionType === 'doc') {
        const comment = prompt("Veuillez ajouter un commentaire pour \"" + actionType + "\" (laisser vide pour ignorer) :");
        if (comment && comment.trim() !== "") {
            addCommentToTask(taskId, comment.trim());
        }

        task.status = actionType;
        task.order = undefined;
        task.modifiedDate = new Date();  // Mettre à jour la date de modification
    }

    saveAndRenderTasks();  // Sauvegarder et rendre la tâche
}


        function parsePeriod(input, baseDate) {
            const regex = /dans\s+les\s+(\d+)\s+prochain(?:es|e)?\s+(semaines|jours|mois)/i;
            const match = input.match(regex);
            if (!match) return null;

            const quantity = parseInt(match[1], 10);
            const unit = match[2].toLowerCase();
            let endDate = new Date(baseDate);

            switch(unit) {
                case 'jours':
                    endDate = Sugar.Date.add(endDate, { days: quantity });
                    break;
                case 'semaines':
                    endDate = Sugar.Date.add(endDate, { weeks: quantity });
                    break;
                case 'mois':
                    endDate = Sugar.Date.add(endDate, { months: quantity });
                    break;
                default:
                    return null;
            }

            return { start: baseDate, end: endDate };
        }

        function getRandomWorkingDay(start, end) {
            const workingDays = [];
            let current = new Date(start);
            while (Sugar.Date.compare(current, end) <= 0) {
                const day = Sugar.Date.getDay(current);
                if (day !== 0 && day !== 6) {
                    workingDays.push(new Date(current));
                }
                current = Sugar.Date.add(current, { days: 1 });
            }
            if (workingDays.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * workingDays.length);
            return workingDays[randomIndex];
        }

        function addComment(event, taskId) {
            if (event.key === 'Enter') {
                const commentText = event.target.value.trim();
                if (commentText) {
                    addCommentToTask(taskId, commentText);
                    event.target.value = '';
                    removeSavedCommentInput(taskId);
                    saveAndRenderTasks();
                }
            }
        }

        function addCommentToTask(taskId, commentText) {
            const task = tasks.find(function(t) {
                return t.id === taskId;
            });
            if (task) {
                task.comments.push({
                    id: Date.now(),
                    text: commentText,
                    date: Sugar.Date.format(new Date(), '%d/%m/%Y %H:%M:%S')
                });
                task.modifiedDate = new Date();
            }
        }

        function editTaskName(taskId) {
            const task = tasks.find(function(t) {
                return t.id === taskId;
            });
            if (task) {
                const newName = prompt("Éditer le nom de la tâche :", task.name);
                if (newName !== null && newName.trim() !== "") {
                    task.name = newName.trim();
                    task.modifiedDate = new Date();
                    saveAndRenderTasks();
                }
            }
        }

        function editTaskDescription(taskId) {
            const task = tasks.find(function(t) {
                return t.id === taskId;
            });
            if (task) {
                const newDescription = prompt("Éditer la description de la tâche :", task.description);
                if (newDescription !== null) {
                    task.description = newDescription.trim();
                    task.modifiedDate = new Date();
                    saveAndRenderTasks();
                }
            }
        }

        function editComment(taskId, commentId) {
            const task = tasks.find(function(t) {
                return t.id === taskId;
            });
            if (task) {
                const comment = task.comments.find(function(c) {
                    return c.id === commentId;
                });
                if (comment) {
                    const newText = prompt("Éditer le commentaire :", comment.text);
                    if (newText !== null && newText.trim() !== "") {
                        comment.text = newText.trim();
                        comment.date = Sugar.Date.format(new Date(), '%d/%m/%Y %H:%M:%S');
                        task.modifiedDate = new Date();
                        saveAndRenderTasks();
                    }
                }
            }
        }

        function confirmDelete(taskId) {
            if (confirm("Êtes-vous sûr de vouloir supprimer cette tâche ? Toutes ses sous-tâches seront également supprimées.")) {
                deleteTask(taskId);
            }
        }

        function deleteTask(taskId) {
            const deleteRecursively = function(id) {
                const subTasks = tasks.filter(function(t) {
                    return t.parentId === id;
                });
                subTasks.forEach(function(subTask) {
                    deleteRecursively(subTask.id);
                });
                tasks = tasks.filter(function(t) {
                    return t.id !== id;
                });
            };
            deleteRecursively(taskId);
            saveAndRenderTasks();
        }

        function convertCommentToTask(taskId, commentId) {
            const parentTask = tasks.find(function(t) {
                return t.id === taskId;
            });
            if (!parentTask) return;
            const comment = parentTask.comments.find(function(c) {
                return c.id === commentId;
            });
            if (!comment) return;
            const parentChain = getParentChain(parentTask);
            const newTask = {
                id: taskIdCounter++,
                name: comment.text,
                description: "",
                comments: [],
                status: "inbox",
                createdDate: new Date(),
                modifiedDate: new Date(),
                collapsed: true,
                targetDate: null,
                parentId: parentTask.id,
                order: getMaxOrder('inbox') + 1
            };
            tasks.push(newTask);
            parentTask.comments = parentTask.comments.filter(function(c) {
                return c.id !== commentId;
            });
            parentTask.modifiedDate = new Date();
            saveAndRenderTasks();
        }

        function getParentChain(task) {
            let chain = [];
            let currentTask = task;
            while (currentTask.parentId !== null) {
                const parentTask = tasks.find(function(t) {
                    return t.id === currentTask.parentId;
                });
                if (parentTask) {
                    chain.unshift(parentTask.name);
                    currentTask = parentTask;
                } else {
                    break;
                }
            }
            return chain;
        }

        function deleteComment(taskId, commentId) {
            const task = tasks.find(function(t) {
                return t.id === taskId;
            });
            if (task) {
                task.comments = task.comments.filter(function(c) {
                    return c.id !== commentId;
                });
                task.modifiedDate = new Date();
                saveAndRenderTasks();
            }
        }

        function saveCommentInput(taskId, value) {
            localStorage.setItem('commentInput-' + taskId, value);
        }

        function getSavedCommentInput(taskId) {
            return localStorage.getItem('commentInput-' + taskId) || '';
        }

        function removeSavedCommentInput(taskId) {
            localStorage.removeItem('commentInput-' + taskId);
        }

        function resetInterface() {
            if (confirm("Êtes-vous sûr de vouloir réinitialiser l'interface ? Toutes les tâches seront supprimées.")) {
                tasks = [];
                taskIdCounter = 0;
                localStorage.removeItem('tasks');
                localStorage.removeItem('taskForm');
                Object.keys(localStorage).forEach(function(key) {
                    if (key.startsWith('commentInput-')) {
                        localStorage.removeItem(key);
                    }
                });
                saveAndRenderTasks();
            }
        }

        function exportData() {
            const data = JSON.stringify(tasks, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tasks.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedTasks = JSON.parse(e.target.result);
                    if (Array.isArray(importedTasks)) {
                        tasks = importedTasks.map(function(task) {
                            return Object.assign({}, task, {
                                order: task.status === 'inbox' ? (task.order || getMaxOrder('inbox') + 1) : undefined
                            });
                        });
                        const maxId = tasks.reduce(function(max, task) {
                            return task.id > max ? task.id : max;
                        }, 0);
                        taskIdCounter = maxId + 1;
                        saveAndRenderTasks();
                        alert("Importation réussie !");
                    } else {
                        alert("Le fichier importé n'est pas valide.");
                    }
                } catch (error) {
                    alert("Erreur lors de l'importation des données.");
                }
            };
            reader.readAsText(file);
        }

function initializeWorker() {
    const workerCode = `
        // Inlined Sugar.js functionality for date handling
        function createDate(input) {
            return new Date(input);
        }

        function isBeforeOrSame(date1, date2) {
            return date1.getTime() <= date2.getTime();
        }

        // Worker logic starts here
        self.onmessage = function(event) {
            if (event.data.action === 'updateTasks') {
                const tasks = event.data.tasks;
                monitorTasks(tasks);
            }
        };

        function monitorTasks(tasks) {
            setInterval(function() {
                const now = new Date();
                let updated = false;
                tasks.forEach(function(task) {
                    if ((task.status === 'delay' || task.status === 'await') && task.targetDate) {
                        const targetDate = createDate(task.targetDate);
                        if (isBeforeOrSame(targetDate, now)) {
                            task.status = 'inbox';
                            task.modifiedDate = new Date();
                            task.order = getMaxOrder(tasks, 'inbox') + 1;
                            task.targetDate = null;
                            updated = true;
                        }
                    }
                });
                if (updated) {
                    postMessage({ action: 'refreshTasks', tasks: tasks });
                }
            }, 1000);
        }

        function getMaxOrder(tasks, status) {
            const filtered = tasks.filter(function(task) {
                return task.status === status;
            });
            if (filtered.length === 0) return 0;
            return Math.max.apply(null, filtered.map(function(task) {
                return task.order || 0;
            }));
        }
    `;

    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const workerURL = URL.createObjectURL(blob);
    worker = new Worker(workerURL);

    worker.onmessage = function(event) {
        if (event.data.action === 'refreshTasks') {
            tasks = event.data.tasks;
            saveAndRenderTasks();
        }
    };

    worker.postMessage({ action: 'updateTasks', tasks: tasks });
}



        function initializeSortable() {
            const taskList = document.getElementById('task-list');
            Sortable.create(taskList, {
                animation: 150,
                handle: '.drag-handle',
                onEnd: function (evt) {
                    const itemEl = evt.item;
                    const movedTaskId = parseInt(itemEl.getAttribute('data-task-id'));
                    const oldIndex = evt.oldIndex;
                    const newIndex = evt.newIndex;

                    let filteredTasks = tasks.filter(function(task) {
                        return task.status === 'inbox';
                    });
                    const movedTask = filteredTasks.splice(oldIndex, 1)[0];
                    filteredTasks.splice(newIndex, 0, movedTask);

                    filteredTasks.forEach(function(task, index) {
                        task.order = index + 1;
                    });

                    saveAndRenderTasks();
                }
            });
        }

        function toggleExportImport() {
            const exportImportDiv = document.getElementById('export-import');
            exportImportDiv.classList.toggle('collapsed');
            const isCollapsed = exportImportDiv.classList.contains('collapsed');
            localStorage.setItem('exportImportCollapsed', isCollapsed.toString());
        }

        function startCountdown() {
            if (countdownInterval) clearInterval(countdownInterval);
            countdownInterval = setInterval(updateCountdowns, 1000);
        }

        function updateCountdowns() {
            tasks.forEach(function(task) {
                if (task.status === 'delay' || task.status === 'await') {
                    const remaining = getRemainingTime(task.targetDate);
                    const taskEl = document.querySelector('[data-task-id="' + task.id + '"]');
                    if (taskEl) {
                        const timerEl = taskEl.querySelector('.timer');
                        if (timerEl) {
                            if (remaining > 0) {
                                timerEl.innerHTML = '<i class="fas fa-clock"></i> ' + formatTime(remaining);
                            } else {
                                timerEl.innerHTML = '<i class="fas fa-clock"></i> 00:00:00';
                            }
                        }
                    }
                }
            });
        }

        function getRemainingTime(targetDate) {
            const now = new Date();
            const target = Sugar.Date.create(targetDate);
            return target - now > 0 ? target - now : 0;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const days = Math.floor(totalSeconds / 86400);
            const hours = Math.floor((totalSeconds % 86400) / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            let parts = [];

            if (days > 0) {
                parts.push(days + 'j');
                if (hours > 0) parts.push(hours + 'h');
            } else if (hours > 0) {
                parts.push(hours + 'h');
                if (minutes > 0) parts.push(minutes + 'm');
            } else if (minutes > 0) {
                parts.push(minutes + 'm');
                if (seconds > 0) parts.push(seconds + 's');
            } else {
                parts.push(seconds + 's');
            }

            return parts.join(' ');
        }

// Custom date expression parser
// Activer la locale française
Sugar.Date.setLocale('fr');

// Fonction générique pour parser les dates
function parseDateExpression(input, baseDate) {
    input = input.toLowerCase().trim();
    const now = baseDate || new Date();  // Utilise la date actuelle ou la date de base fournie

    // Gérer les cas de "demain" ou "tomorrow"
    if (input === "demain" || input === "tomorrow") {
        return Sugar.Date.advance(now, { days: 1 });
    } else if (input === "après-demain" || input === "day after tomorrow" || input === "apres demain" || input === "après demain") {
        return Sugar.Date.advance(now, { days: 2 });
    }

    // Gérer les expressions relatives comme "dans 3 heures", "dans 2 minutes"
    const matchRelativeTime = input.match(/dans\s+(\d+)\s+(minutes?|heures?|jours?|secondes?)/);
    if (matchRelativeTime) {
        const value = parseInt(matchRelativeTime[1], 10);
        const unit = matchRelativeTime[2];

        let futureDate;
        switch (unit) {
            case 'minute':
            case 'minutes':
                futureDate = Sugar.Date.advance(now, { minutes: value });
                break;
            case 'heure':
            case 'heures':
                futureDate = Sugar.Date.advance(now, { hours: value });
                break;
            case 'jour':
            case 'jours':
                futureDate = Sugar.Date.advance(now, { days: value });
                break;
            case 'seconde':
            case 'secondes':
                futureDate = Sugar.Date.advance(now, { seconds: value });
                break;
        }

        // Retourner la date future validée
        if (Sugar.Date.isValid(futureDate) && Sugar.Date.isFuture(futureDate)) {
            return futureDate;
        }
        return null;
    }

    // Tenter de parser des expressions standards comme "lundi prochain"
    const parsedDate = Sugar.Date.create(input, { from: now });
    
    // Vérification étape par étape pour mieux comprendre ce qui échoue
    // console.log("Parsed Date:", parsedDate);
    // console.log("Is Valid:", Sugar.Date.isValid(parsedDate));
    // console.log("Is Future:", Sugar.Date.isFuture(parsedDate));

    if (Sugar.Date.isValid(parsedDate) && Sugar.Date.isFuture(parsedDate)) {
        return parsedDate;
    }

    return null;  // Retourner null si la date n'est pas valide
}

// Fonction pour modifier la deadline d'une tâche (dans delay/await ou tout autre onglet)
function modifyDeadline(taskId) {
    const task = tasks.find(t => t.id === taskId);
    if (!task) return;

    const baseDate = task.modifiedDate ? new Date(task.modifiedDate) : new Date(task.createdDate);
    let newTargetDate = null;

    while (true) {
        const dateInput = prompt(`Modifier la deadline pour "${task.name}". Veuillez fournir une nouvelle date (ex : demain, lundi prochain, dans 3 heures) :`);
        if (dateInput === null) return;

        const parsedDate = parseDateExpression(dateInput, baseDate);  // Appeler la fonction pour parser l'entrée utilisateur
        
        if (parsedDate) {
            newTargetDate = parsedDate;
            task.targetDate = newTargetDate;
            task.modifiedDate = new Date();  // Mettre à jour la date modifiée
            break;
        } else {
            alert("Veuillez fournir une date valide et future.");
        }
    }

    saveAndRenderTasks();  // Sauvegarder et rendre la nouvelle tâche
}



    </script>
</body>
</html>
